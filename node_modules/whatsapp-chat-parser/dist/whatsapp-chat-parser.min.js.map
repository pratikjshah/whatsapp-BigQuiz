{"version":3,"file":"whatsapp-chat-parser.min.js","sources":["../src/utils.js","../src/date.js","../src/time.js","../src/parser.js","../src/index.js"],"sourcesContent":["/**\n * Checks that an item at a certain index of an array is greater than a certain\n * value\n */\nfunction indexAboveValue(index, value) {\n  return array => array[index] > value;\n}\n\n/**\n * Returns true for a negative number, false otherwise\n * 0 is considered positive\n */\nfunction isNegative(number) {\n  return number < 0;\n}\n\n/**\n * Given an array of arrays and an index, gropus the inner arrays by the value\n * at the index provided\n * See test cases for a better understanding of this function\n */\nfunction groupArrayByValueAtIndex(array, index) {\n  return Object.values(\n    array.reduce((obj, item) => {\n      /**\n       * Keys that are only numbers get sorted when using Object.values()\n       * Adding a prefix avoids this issue\n       */\n      const key = `key_${item[index]}`;\n\n      if (!obj[key]) {\n        obj[key] = [];\n      }\n\n      obj[key].push(item);\n\n      return obj;\n    }, {}),\n  );\n}\n\nmodule.exports = { indexAboveValue, isNegative, groupArrayByValueAtIndex };\n","const {\n  indexAboveValue,\n  isNegative,\n  groupArrayByValueAtIndex,\n} = require('./utils.js');\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if numbers go above 12\n *\n * Output is true if days are first, false if they are second, or null if it\n * failed to understand the order\n */\nfunction checkAbove12(numericDates) {\n  const daysFirst = numericDates.some(indexAboveValue(0, 12));\n\n  if (daysFirst) {\n    return true;\n  }\n\n  const daysSecond = numericDates.some(indexAboveValue(1, 12));\n\n  if (daysSecond) {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if a set of numbers\n * during the same year decrease at some point\n * If it does it's probably the days since months can only increase in a given\n * year\n *\n * Output is true if days are first, false if they are second, or null if it\n * failed to understand the order\n */\nfunction checkDecreasing(numericDates) {\n  const datesByYear = groupArrayByValueAtIndex(numericDates, 2);\n  const results = datesByYear.map(dates => {\n    const daysFirst = dates.slice(1).some((date, i) => {\n      const [first1] = dates[i];\n      const [first2] = date;\n\n      return isNegative(first2 - first1);\n    });\n\n    if (daysFirst) {\n      return true;\n    }\n\n    const daysSecond = dates.slice(1).some((date, i) => {\n      const [, second1] = dates[i];\n      const [, second2] = date;\n\n      return isNegative(second2 - second1);\n    });\n\n    if (daysSecond) {\n      return false;\n    }\n\n    return null;\n  });\n\n  const anyTrue = results.some(value => value === true);\n\n  if (anyTrue) {\n    return true;\n  }\n\n  const anyFalse = results.some(value => value === false);\n\n  if (anyFalse) {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by looking at which number changes\n * more frequently\n *\n * Output is true if days are first, false if they are second, or null if it\n * failed to understand the order\n */\nfunction changeFrequencyAnalysis(numericDates) {\n  const diffs = numericDates\n    .slice(1)\n    .map((date, i) => date.map((num, j) => Math.abs(numericDates[i][j] - num)));\n  const [first, second] = diffs.reduce(\n    (total, diff) => {\n      const [first1, second1] = total;\n      const [first2, second2] = diff;\n\n      return [first1 + first2, second1 + second2];\n    },\n    [0, 0],\n  );\n\n  if (first > second) {\n    return true;\n  }\n\n  if (first < second) {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by running the dates through all\n * checks (checkAbove12, checkDecreasing, changeFrequencyAnalysis)\n *\n * Output is true if days are first, false if they are second, or null if it\n * failed to understand the order\n */\nfunction daysBeforeMonths(numericDates) {\n  const firstCheck = checkAbove12(numericDates);\n\n  if (firstCheck !== null) {\n    return firstCheck;\n  }\n\n  const secondCheck = checkDecreasing(numericDates);\n\n  if (secondCheck !== null) {\n    return secondCheck;\n  }\n\n  return changeFrequencyAnalysis(numericDates);\n}\n\n/**\n * Takes year, month and day as strings and pads them as needed\n */\nfunction normalizeDate(year, month, day) {\n  return [\n    year.padStart(4, '2000'),\n    month.padStart(2, '0'),\n    day.padStart(2, '0'),\n  ];\n}\n\nmodule.exports = {\n  checkAbove12,\n  checkDecreasing,\n  changeFrequencyAnalysis,\n  daysBeforeMonths,\n  normalizeDate,\n};\n","const regexSplitTime = /[:.]/;\n\n/**\n * Converts time from 12 hour format to 24 hour format\n * From: https://stackoverflow.com/a/40197728/5303634\n */\nfunction convertTime12to24(time, ampm) {\n  // eslint-disable-next-line prefer-const\n  let [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  if (hours === '12') {\n    hours = '00';\n  }\n\n  if (ampm === 'PM') {\n    hours = parseInt(hours, 10) + 12;\n  }\n\n  return `${hours}:${minutes}${seconds ? `:${seconds}` : ''}`;\n}\n\n/**\n * Normalizes a time string to have the following format: hh:mm:ss\n */\nfunction normalizeTime(time) {\n  const [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  return `${hours.length === 1 ? `0${hours}` : hours}:${minutes}:${seconds ||\n    '00'}`;\n}\n\n/**\n * Normalizes am / a.m. / etc. to AM (uppercase, no other characters)\n */\nfunction normalizeAMPM(ampm) {\n  return ampm.replace(/[^apm]/gi, '').toUpperCase();\n}\n\nmodule.exports = {\n  regexSplitTime,\n  convertTime12to24,\n  normalizeTime,\n  normalizeAMPM,\n};\n","const { daysBeforeMonths, normalizeDate } = require('./date.js');\nconst {\n  regexSplitTime,\n  convertTime12to24,\n  normalizeAMPM,\n  normalizeTime,\n} = require('./time.js');\n\nconst regexParser = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?(?: -|:)? (.+?): ([^]*)/i;\nconst regexParserSystem = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?(?: -|:)? ([^]+)/i;\nconst regexStartsWithDateTime = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?/i;\nconst regexSplitDate = /[-/.] ?/;\n\n/**\n * Given an array of lines, detects the lines that are part of a previous\n * message (multiline messages) and merges them\n * It also labels the system messages\n * The result is an array of messages\n */\nfunction makeArrayOfMessages(lines) {\n  return lines.reduce((acc, line) => {\n    /**\n     * If the line doesn't conform to the regex it's probably part of the\n     * previous message or a \"whatsapp event\"\n     */\n    if (!regexParser.test(line)) {\n      /**\n       * If it doesn't match the first regex but still starts with a datetime\n       * it should be considered a \"whatsapp event\" so it gets labeled \"system\"\n       */\n      if (regexStartsWithDateTime.test(line)) {\n        acc.push({ system: true, msg: line });\n      }\n\n      // Else it's part of the previous message and it should be concatenated\n      else if (typeof acc[acc.length - 1] !== 'undefined') {\n        const prevMessage = acc.pop();\n\n        acc.push({\n          system: prevMessage.system,\n          msg: `${prevMessage.msg}\\n${line}`,\n        });\n      }\n    } else {\n      acc.push({ system: false, msg: line });\n    }\n\n    return acc;\n  }, []);\n}\n\n/**\n * Given an array of messages, parses them and returns an object with the fields\n * date, author, message\n */\nfunction parseMessages(messages, options = { daysFirst: undefined }) {\n  let { daysFirst } = options;\n\n  // Parse messages with regex\n  const parsed = messages.map(obj => {\n    const { system, msg } = obj;\n\n    // If it's a system message another regex should be used to parse it\n    if (system) {\n      const [, date, time, ampm, message] = regexParserSystem.exec(msg);\n\n      return { date, time, ampm: ampm || null, author: 'System', message };\n    }\n\n    const [, date, time, ampm, author, message] = regexParser.exec(msg);\n\n    return { date, time, ampm: ampm || null, author, message };\n  });\n\n  // Understand date format if not supplied (days come first?)\n  if (typeof daysFirst !== 'boolean') {\n    const numericDates = Array.from(\n      new Set(parsed.map(({ date }) => date)),\n      date => date.split(regexSplitDate).map(Number),\n    );\n\n    daysFirst = daysBeforeMonths(numericDates);\n  }\n\n  // Convert date/time in date object, return final object\n  return parsed.map(({ date, time, ampm, author, message }) => {\n    let day;\n    let month;\n    let year;\n\n    if (daysFirst === false) {\n      [month, day, year] = date.split(regexSplitDate);\n    } else {\n      [day, month, year] = date.split(regexSplitDate);\n    }\n\n    [year, month, day] = normalizeDate(year, month, day);\n\n    const [hours, minutes, seconds] = normalizeTime(\n      ampm ? convertTime12to24(time, normalizeAMPM(ampm)) : time,\n    ).split(regexSplitTime);\n\n    return {\n      date: new Date(year, month - 1, day, hours, minutes, seconds),\n      author,\n      message,\n    };\n  });\n}\n\nmodule.exports = {\n  makeArrayOfMessages,\n  parseMessages,\n};\n","const { makeArrayOfMessages, parseMessages } = require('./parser.js');\n\n/**\n * Given a string it will parse its content\n * Returns a promise that will contain the parsed messages\n */\nfunction parseString(string, options) {\n  return Promise.resolve(string)\n    .then(data => data.split('\\n'))\n    .then(makeArrayOfMessages)\n    .then(messages => parseMessages(messages, options));\n}\n\nmodule.exports = { parseString };\n"],"names":["indexAboveValue","index","value","array","isNegative","number","groupArrayByValueAtIndex","Object","values","reduce","obj","item","key","push","checkAbove12","numericDates","some","checkDecreasing","results","map","dates","slice","date","i","first1","first2","second1","second2","changeFrequencyAnalysis","num","j","Math","abs","total","diff","first","second","regexSplitTime","daysBeforeMonths","firstCheck","secondCheck","normalizeDate","year","month","day","padStart","convertTime12to24","time","ampm","split","hours","minutes","seconds","parseInt","normalizeAMPM","replace","toUpperCase","normalizeTime","length","regexParser","regexParserSystem","regexStartsWithDateTime","regexSplitDate","makeArrayOfMessages","lines","acc","line","test","system","msg","prevMessage","pop","parseMessages","messages","daysFirst","undefined","parsed","exec","author","message","Array","from","Set","Number","Date","parseString","string","options","Promise","resolve","then","data"],"mappings":"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"}