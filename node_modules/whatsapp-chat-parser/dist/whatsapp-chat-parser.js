(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.whatsappChatParser = {}));
}(this, function (exports) { 'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * Checks that an item at a certain index of an array is greater than a certain
   * value
   */
  function indexAboveValue(index, value) {
    return function (array) {
      return array[index] > value;
    };
  }
  /**
   * Returns true for a negative number, false otherwise
   * 0 is considered positive
   */


  function isNegative(number) {
    return number < 0;
  }
  /**
   * Given an array of arrays and an index, gropus the inner arrays by the value
   * at the index provided
   * See test cases for a better understanding of this function
   */


  function groupArrayByValueAtIndex(array, index) {
    return Object.values(array.reduce(function (obj, item) {
      /**
       * Keys that are only numbers get sorted when using Object.values()
       * Adding a prefix avoids this issue
       */
      var key = "key_".concat(item[index]);

      if (!obj[key]) {
        obj[key] = [];
      }

      obj[key].push(item);
      return obj;
    }, {}));
  }

  var utils = {
    indexAboveValue: indexAboveValue,
    isNegative: isNegative,
    groupArrayByValueAtIndex: groupArrayByValueAtIndex
  };

  var indexAboveValue$1 = utils.indexAboveValue,
      isNegative$1 = utils.isNegative,
      groupArrayByValueAtIndex$1 = utils.groupArrayByValueAtIndex;
  /**
   * Takes an array of numeric dates and tries to understand if the days come
   * before the month or the other way around by checking if numbers go above 12
   *
   * Output is true if days are first, false if they are second, or null if it
   * failed to understand the order
   */

  function checkAbove12(numericDates) {
    var daysFirst = numericDates.some(indexAboveValue$1(0, 12));

    if (daysFirst) {
      return true;
    }

    var daysSecond = numericDates.some(indexAboveValue$1(1, 12));

    if (daysSecond) {
      return false;
    }

    return null;
  }
  /**
   * Takes an array of numeric dates and tries to understand if the days come
   * before the month or the other way around by checking if a set of numbers
   * during the same year decrease at some point
   * If it does it's probably the days since months can only increase in a given
   * year
   *
   * Output is true if days are first, false if they are second, or null if it
   * failed to understand the order
   */


  function checkDecreasing(numericDates) {
    var datesByYear = groupArrayByValueAtIndex$1(numericDates, 2);
    var results = datesByYear.map(function (dates) {
      var daysFirst = dates.slice(1).some(function (date, i) {
        var _dates$i = _slicedToArray(dates[i], 1),
            first1 = _dates$i[0];

        var _date = _slicedToArray(date, 1),
            first2 = _date[0];

        return isNegative$1(first2 - first1);
      });

      if (daysFirst) {
        return true;
      }

      var daysSecond = dates.slice(1).some(function (date, i) {
        var _dates$i2 = _slicedToArray(dates[i], 2),
            second1 = _dates$i2[1];

        var _date2 = _slicedToArray(date, 2),
            second2 = _date2[1];

        return isNegative$1(second2 - second1);
      });

      if (daysSecond) {
        return false;
      }

      return null;
    });
    var anyTrue = results.some(function (value) {
      return value === true;
    });

    if (anyTrue) {
      return true;
    }

    var anyFalse = results.some(function (value) {
      return value === false;
    });

    if (anyFalse) {
      return false;
    }

    return null;
  }
  /**
   * Takes an array of numeric dates and tries to understand if the days come
   * before the month or the other way around by looking at which number changes
   * more frequently
   *
   * Output is true if days are first, false if they are second, or null if it
   * failed to understand the order
   */


  function changeFrequencyAnalysis(numericDates) {
    var diffs = numericDates.slice(1).map(function (date, i) {
      return date.map(function (num, j) {
        return Math.abs(numericDates[i][j] - num);
      });
    });

    var _diffs$reduce = diffs.reduce(function (total, diff) {
      var _total = _slicedToArray(total, 2),
          first1 = _total[0],
          second1 = _total[1];

      var _diff = _slicedToArray(diff, 2),
          first2 = _diff[0],
          second2 = _diff[1];

      return [first1 + first2, second1 + second2];
    }, [0, 0]),
        _diffs$reduce2 = _slicedToArray(_diffs$reduce, 2),
        first = _diffs$reduce2[0],
        second = _diffs$reduce2[1];

    if (first > second) {
      return true;
    }

    if (first < second) {
      return false;
    }

    return null;
  }
  /**
   * Takes an array of numeric dates and tries to understand if the days come
   * before the month or the other way around by running the dates through all
   * checks (checkAbove12, checkDecreasing, changeFrequencyAnalysis)
   *
   * Output is true if days are first, false if they are second, or null if it
   * failed to understand the order
   */


  function daysBeforeMonths(numericDates) {
    var firstCheck = checkAbove12(numericDates);

    if (firstCheck !== null) {
      return firstCheck;
    }

    var secondCheck = checkDecreasing(numericDates);

    if (secondCheck !== null) {
      return secondCheck;
    }

    return changeFrequencyAnalysis(numericDates);
  }
  /**
   * Takes year, month and day as strings and pads them as needed
   */


  function normalizeDate(year, month, day) {
    return [year.padStart(4, '2000'), month.padStart(2, '0'), day.padStart(2, '0')];
  }

  var date = {
    checkAbove12: checkAbove12,
    checkDecreasing: checkDecreasing,
    changeFrequencyAnalysis: changeFrequencyAnalysis,
    daysBeforeMonths: daysBeforeMonths,
    normalizeDate: normalizeDate
  };

  var regexSplitTime = /[:.]/;
  /**
   * Converts time from 12 hour format to 24 hour format
   * From: https://stackoverflow.com/a/40197728/5303634
   */

  function convertTime12to24(time, ampm) {
    // eslint-disable-next-line prefer-const
    var _time$split = time.split(regexSplitTime),
        _time$split2 = _slicedToArray(_time$split, 3),
        hours = _time$split2[0],
        minutes = _time$split2[1],
        seconds = _time$split2[2];

    if (hours === '12') {
      hours = '00';
    }

    if (ampm === 'PM') {
      hours = parseInt(hours, 10) + 12;
    }

    return "".concat(hours, ":").concat(minutes).concat(seconds ? ":".concat(seconds) : '');
  }
  /**
   * Normalizes a time string to have the following format: hh:mm:ss
   */


  function normalizeTime(time) {
    var _time$split3 = time.split(regexSplitTime),
        _time$split4 = _slicedToArray(_time$split3, 3),
        hours = _time$split4[0],
        minutes = _time$split4[1],
        seconds = _time$split4[2];

    return "".concat(hours.length === 1 ? "0".concat(hours) : hours, ":").concat(minutes, ":").concat(seconds || '00');
  }
  /**
   * Normalizes am / a.m. / etc. to AM (uppercase, no other characters)
   */


  function normalizeAMPM(ampm) {
    return ampm.replace(/[^apm]/gi, '').toUpperCase();
  }

  var time = {
    regexSplitTime: regexSplitTime,
    convertTime12to24: convertTime12to24,
    normalizeTime: normalizeTime,
    normalizeAMPM: normalizeAMPM
  };

  var daysBeforeMonths$1 = date.daysBeforeMonths,
      normalizeDate$1 = date.normalizeDate;
  var regexSplitTime$1 = time.regexSplitTime,
      convertTime12to24$1 = time.convertTime12to24,
      normalizeAMPM$1 = time.normalizeAMPM,
      normalizeTime$1 = time.normalizeTime;
  var regexParser = /^(?:\u200E|\u200F)*\[?(\d{1,2}[-/.] ?\d{1,2}[-/.] ?\d{2,4})[,.]? \D*?(\d{1,2}[.:]\d{1,2}(?:[.:]\d{1,2})?)(?: ([ap]\.? ?m\.?))?\]?(?: -|:)? (.+?): ([^]*)/i;
  var regexParserSystem = /^(?:\u200E|\u200F)*\[?(\d{1,2}[-/.] ?\d{1,2}[-/.] ?\d{2,4})[,.]? \D*?(\d{1,2}[.:]\d{1,2}(?:[.:]\d{1,2})?)(?: ([ap]\.? ?m\.?))?\]?(?: -|:)? ([^]+)/i;
  var regexStartsWithDateTime = /^(?:\u200E|\u200F)*\[?(\d{1,2}[-/.] ?\d{1,2}[-/.] ?\d{2,4})[,.]? \D*?(\d{1,2}[.:]\d{1,2}(?:[.:]\d{1,2})?)(?: ([ap]\.? ?m\.?))?\]?/i;
  var regexSplitDate = /[-/.] ?/;
  /**
   * Given an array of lines, detects the lines that are part of a previous
   * message (multiline messages) and merges them
   * It also labels the system messages
   * The result is an array of messages
   */

  function makeArrayOfMessages(lines) {
    return lines.reduce(function (acc, line) {
      /**
       * If the line doesn't conform to the regex it's probably part of the
       * previous message or a "whatsapp event"
       */
      if (!regexParser.test(line)) {
        /**
         * If it doesn't match the first regex but still starts with a datetime
         * it should be considered a "whatsapp event" so it gets labeled "system"
         */
        if (regexStartsWithDateTime.test(line)) {
          acc.push({
            system: true,
            msg: line
          });
        } // Else it's part of the previous message and it should be concatenated
        else if (typeof acc[acc.length - 1] !== 'undefined') {
            var prevMessage = acc.pop();
            acc.push({
              system: prevMessage.system,
              msg: "".concat(prevMessage.msg, "\n").concat(line)
            });
          }
      } else {
        acc.push({
          system: false,
          msg: line
        });
      }

      return acc;
    }, []);
  }
  /**
   * Given an array of messages, parses them and returns an object with the fields
   * date, author, message
   */


  function parseMessages(messages) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      daysFirst: undefined
    };
    var daysFirst = options.daysFirst; // Parse messages with regex

    var parsed = messages.map(function (obj) {
      var system = obj.system,
          msg = obj.msg; // If it's a system message another regex should be used to parse it

      if (system) {
        var _regexParserSystem$ex = regexParserSystem.exec(msg),
            _regexParserSystem$ex2 = _slicedToArray(_regexParserSystem$ex, 5),
            _date = _regexParserSystem$ex2[1],
            _time = _regexParserSystem$ex2[2],
            _ampm = _regexParserSystem$ex2[3],
            _message = _regexParserSystem$ex2[4];

        return {
          date: _date,
          time: _time,
          ampm: _ampm || null,
          author: 'System',
          message: _message
        };
      }

      var _regexParser$exec = regexParser.exec(msg),
          _regexParser$exec2 = _slicedToArray(_regexParser$exec, 6),
          date = _regexParser$exec2[1],
          time = _regexParser$exec2[2],
          ampm = _regexParser$exec2[3],
          author = _regexParser$exec2[4],
          message = _regexParser$exec2[5];

      return {
        date: date,
        time: time,
        ampm: ampm || null,
        author: author,
        message: message
      };
    }); // Understand date format if not supplied (days come first?)

    if (typeof daysFirst !== 'boolean') {
      var numericDates = Array.from(new Set(parsed.map(function (_ref) {
        var date = _ref.date;
        return date;
      })), function (date) {
        return date.split(regexSplitDate).map(Number);
      });
      daysFirst = daysBeforeMonths$1(numericDates);
    } // Convert date/time in date object, return final object


    return parsed.map(function (_ref2) {
      var date = _ref2.date,
          time = _ref2.time,
          ampm = _ref2.ampm,
          author = _ref2.author,
          message = _ref2.message;
      var day;
      var month;
      var year;

      if (daysFirst === false) {
        var _date$split = date.split(regexSplitDate);

        var _date$split2 = _slicedToArray(_date$split, 3);

        month = _date$split2[0];
        day = _date$split2[1];
        year = _date$split2[2];
      } else {
        var _date$split3 = date.split(regexSplitDate);

        var _date$split4 = _slicedToArray(_date$split3, 3);

        day = _date$split4[0];
        month = _date$split4[1];
        year = _date$split4[2];
      }

      var _normalizeDate = normalizeDate$1(year, month, day);

      var _normalizeDate2 = _slicedToArray(_normalizeDate, 3);

      year = _normalizeDate2[0];
      month = _normalizeDate2[1];
      day = _normalizeDate2[2];

      var _normalizeTime$split = normalizeTime$1(ampm ? convertTime12to24$1(time, normalizeAMPM$1(ampm)) : time).split(regexSplitTime$1),
          _normalizeTime$split2 = _slicedToArray(_normalizeTime$split, 3),
          hours = _normalizeTime$split2[0],
          minutes = _normalizeTime$split2[1],
          seconds = _normalizeTime$split2[2];

      return {
        date: new Date(year, month - 1, day, hours, minutes, seconds),
        author: author,
        message: message
      };
    });
  }

  var parser = {
    makeArrayOfMessages: makeArrayOfMessages,
    parseMessages: parseMessages
  };

  var makeArrayOfMessages$1 = parser.makeArrayOfMessages,
      parseMessages$1 = parser.parseMessages;
  /**
   * Given a string it will parse its content
   * Returns a promise that will contain the parsed messages
   */

  function parseString(string, options) {
    return Promise.resolve(string).then(function (data) {
      return data.split('\n');
    }).then(makeArrayOfMessages$1).then(function (messages) {
      return parseMessages$1(messages, options);
    });
  }

  var src = {
    parseString: parseString
  };
  var src_1 = src.parseString;

  exports.default = src;
  exports.parseString = src_1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=whatsapp-chat-parser.js.map
