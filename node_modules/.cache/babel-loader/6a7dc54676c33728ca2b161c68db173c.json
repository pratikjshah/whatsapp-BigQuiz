{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.whatsappChatParser = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n  /**\n   * Checks that an item at a certain index of an array is greater than a certain\n   * value\n   */\n\n\n  function indexAboveValue(index, value) {\n    return function (array) {\n      return array[index] > value;\n    };\n  }\n  /**\n   * Returns true for a negative number, false otherwise\n   * 0 is considered positive\n   */\n\n\n  function isNegative(number) {\n    return number < 0;\n  }\n  /**\n   * Given an array of arrays and an index, gropus the inner arrays by the value\n   * at the index provided\n   * See test cases for a better understanding of this function\n   */\n\n\n  function groupArrayByValueAtIndex(array, index) {\n    return Object.values(array.reduce(function (obj, item) {\n      /**\n       * Keys that are only numbers get sorted when using Object.values()\n       * Adding a prefix avoids this issue\n       */\n      var key = \"key_\".concat(item[index]);\n\n      if (!obj[key]) {\n        obj[key] = [];\n      }\n\n      obj[key].push(item);\n      return obj;\n    }, {}));\n  }\n\n  var utils = {\n    indexAboveValue: indexAboveValue,\n    isNegative: isNegative,\n    groupArrayByValueAtIndex: groupArrayByValueAtIndex\n  };\n  var indexAboveValue$1 = utils.indexAboveValue,\n      isNegative$1 = utils.isNegative,\n      groupArrayByValueAtIndex$1 = utils.groupArrayByValueAtIndex;\n  /**\n   * Takes an array of numeric dates and tries to understand if the days come\n   * before the month or the other way around by checking if numbers go above 12\n   *\n   * Output is true if days are first, false if they are second, or null if it\n   * failed to understand the order\n   */\n\n  function checkAbove12(numericDates) {\n    var daysFirst = numericDates.some(indexAboveValue$1(0, 12));\n\n    if (daysFirst) {\n      return true;\n    }\n\n    var daysSecond = numericDates.some(indexAboveValue$1(1, 12));\n\n    if (daysSecond) {\n      return false;\n    }\n\n    return null;\n  }\n  /**\n   * Takes an array of numeric dates and tries to understand if the days come\n   * before the month or the other way around by checking if a set of numbers\n   * during the same year decrease at some point\n   * If it does it's probably the days since months can only increase in a given\n   * year\n   *\n   * Output is true if days are first, false if they are second, or null if it\n   * failed to understand the order\n   */\n\n\n  function checkDecreasing(numericDates) {\n    var datesByYear = groupArrayByValueAtIndex$1(numericDates, 2);\n    var results = datesByYear.map(function (dates) {\n      var daysFirst = dates.slice(1).some(function (date, i) {\n        var _dates$i = _slicedToArray(dates[i], 1),\n            first1 = _dates$i[0];\n\n        var _date = _slicedToArray(date, 1),\n            first2 = _date[0];\n\n        return isNegative$1(first2 - first1);\n      });\n\n      if (daysFirst) {\n        return true;\n      }\n\n      var daysSecond = dates.slice(1).some(function (date, i) {\n        var _dates$i2 = _slicedToArray(dates[i], 2),\n            second1 = _dates$i2[1];\n\n        var _date2 = _slicedToArray(date, 2),\n            second2 = _date2[1];\n\n        return isNegative$1(second2 - second1);\n      });\n\n      if (daysSecond) {\n        return false;\n      }\n\n      return null;\n    });\n    var anyTrue = results.some(function (value) {\n      return value === true;\n    });\n\n    if (anyTrue) {\n      return true;\n    }\n\n    var anyFalse = results.some(function (value) {\n      return value === false;\n    });\n\n    if (anyFalse) {\n      return false;\n    }\n\n    return null;\n  }\n  /**\n   * Takes an array of numeric dates and tries to understand if the days come\n   * before the month or the other way around by looking at which number changes\n   * more frequently\n   *\n   * Output is true if days are first, false if they are second, or null if it\n   * failed to understand the order\n   */\n\n\n  function changeFrequencyAnalysis(numericDates) {\n    var diffs = numericDates.slice(1).map(function (date, i) {\n      return date.map(function (num, j) {\n        return Math.abs(numericDates[i][j] - num);\n      });\n    });\n\n    var _diffs$reduce = diffs.reduce(function (total, diff) {\n      var _total = _slicedToArray(total, 2),\n          first1 = _total[0],\n          second1 = _total[1];\n\n      var _diff = _slicedToArray(diff, 2),\n          first2 = _diff[0],\n          second2 = _diff[1];\n\n      return [first1 + first2, second1 + second2];\n    }, [0, 0]),\n        _diffs$reduce2 = _slicedToArray(_diffs$reduce, 2),\n        first = _diffs$reduce2[0],\n        second = _diffs$reduce2[1];\n\n    if (first > second) {\n      return true;\n    }\n\n    if (first < second) {\n      return false;\n    }\n\n    return null;\n  }\n  /**\n   * Takes an array of numeric dates and tries to understand if the days come\n   * before the month or the other way around by running the dates through all\n   * checks (checkAbove12, checkDecreasing, changeFrequencyAnalysis)\n   *\n   * Output is true if days are first, false if they are second, or null if it\n   * failed to understand the order\n   */\n\n\n  function daysBeforeMonths(numericDates) {\n    var firstCheck = checkAbove12(numericDates);\n\n    if (firstCheck !== null) {\n      return firstCheck;\n    }\n\n    var secondCheck = checkDecreasing(numericDates);\n\n    if (secondCheck !== null) {\n      return secondCheck;\n    }\n\n    return changeFrequencyAnalysis(numericDates);\n  }\n  /**\n   * Takes year, month and day as strings and pads them as needed\n   */\n\n\n  function normalizeDate(year, month, day) {\n    return [year.padStart(4, '2000'), month.padStart(2, '0'), day.padStart(2, '0')];\n  }\n\n  var date = {\n    checkAbove12: checkAbove12,\n    checkDecreasing: checkDecreasing,\n    changeFrequencyAnalysis: changeFrequencyAnalysis,\n    daysBeforeMonths: daysBeforeMonths,\n    normalizeDate: normalizeDate\n  };\n  var regexSplitTime = /[:.]/;\n  /**\n   * Converts time from 12 hour format to 24 hour format\n   * From: https://stackoverflow.com/a/40197728/5303634\n   */\n\n  function convertTime12to24(time, ampm) {\n    // eslint-disable-next-line prefer-const\n    var _time$split = time.split(regexSplitTime),\n        _time$split2 = _slicedToArray(_time$split, 3),\n        hours = _time$split2[0],\n        minutes = _time$split2[1],\n        seconds = _time$split2[2];\n\n    if (hours === '12') {\n      hours = '00';\n    }\n\n    if (ampm === 'PM') {\n      hours = parseInt(hours, 10) + 12;\n    }\n\n    return \"\".concat(hours, \":\").concat(minutes).concat(seconds ? \":\".concat(seconds) : '');\n  }\n  /**\n   * Normalizes a time string to have the following format: hh:mm:ss\n   */\n\n\n  function normalizeTime(time) {\n    var _time$split3 = time.split(regexSplitTime),\n        _time$split4 = _slicedToArray(_time$split3, 3),\n        hours = _time$split4[0],\n        minutes = _time$split4[1],\n        seconds = _time$split4[2];\n\n    return \"\".concat(hours.length === 1 ? \"0\".concat(hours) : hours, \":\").concat(minutes, \":\").concat(seconds || '00');\n  }\n  /**\n   * Normalizes am / a.m. / etc. to AM (uppercase, no other characters)\n   */\n\n\n  function normalizeAMPM(ampm) {\n    return ampm.replace(/[^apm]/gi, '').toUpperCase();\n  }\n\n  var time = {\n    regexSplitTime: regexSplitTime,\n    convertTime12to24: convertTime12to24,\n    normalizeTime: normalizeTime,\n    normalizeAMPM: normalizeAMPM\n  };\n  var daysBeforeMonths$1 = date.daysBeforeMonths,\n      normalizeDate$1 = date.normalizeDate;\n  var regexSplitTime$1 = time.regexSplitTime,\n      convertTime12to24$1 = time.convertTime12to24,\n      normalizeAMPM$1 = time.normalizeAMPM,\n      normalizeTime$1 = time.normalizeTime;\n  var regexParser = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?(?: -|:)? (.+?): ([^]*)/i;\n  var regexParserSystem = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?(?: -|:)? ([^]+)/i;\n  var regexStartsWithDateTime = /^(?:\\u200E|\\u200F)*\\[?(\\d{1,2}[-/.] ?\\d{1,2}[-/.] ?\\d{2,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.? ?m\\.?))?\\]?/i;\n  var regexSplitDate = /[-/.] ?/;\n  /**\n   * Given an array of lines, detects the lines that are part of a previous\n   * message (multiline messages) and merges them\n   * It also labels the system messages\n   * The result is an array of messages\n   */\n\n  function makeArrayOfMessages(lines) {\n    return lines.reduce(function (acc, line) {\n      /**\n       * If the line doesn't conform to the regex it's probably part of the\n       * previous message or a \"whatsapp event\"\n       */\n      if (!regexParser.test(line)) {\n        /**\n         * If it doesn't match the first regex but still starts with a datetime\n         * it should be considered a \"whatsapp event\" so it gets labeled \"system\"\n         */\n        if (regexStartsWithDateTime.test(line)) {\n          acc.push({\n            system: true,\n            msg: line\n          });\n        } // Else it's part of the previous message and it should be concatenated\n        else if (typeof acc[acc.length - 1] !== 'undefined') {\n            var prevMessage = acc.pop();\n            acc.push({\n              system: prevMessage.system,\n              msg: \"\".concat(prevMessage.msg, \"\\n\").concat(line)\n            });\n          }\n      } else {\n        acc.push({\n          system: false,\n          msg: line\n        });\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\n   * Given an array of messages, parses them and returns an object with the fields\n   * date, author, message\n   */\n\n\n  function parseMessages(messages) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      daysFirst: undefined\n    };\n    var daysFirst = options.daysFirst; // Parse messages with regex\n\n    var parsed = messages.map(function (obj) {\n      var system = obj.system,\n          msg = obj.msg; // If it's a system message another regex should be used to parse it\n\n      if (system) {\n        var _regexParserSystem$ex = regexParserSystem.exec(msg),\n            _regexParserSystem$ex2 = _slicedToArray(_regexParserSystem$ex, 5),\n            _date = _regexParserSystem$ex2[1],\n            _time = _regexParserSystem$ex2[2],\n            _ampm = _regexParserSystem$ex2[3],\n            _message = _regexParserSystem$ex2[4];\n\n        return {\n          date: _date,\n          time: _time,\n          ampm: _ampm || null,\n          author: 'System',\n          message: _message\n        };\n      }\n\n      var _regexParser$exec = regexParser.exec(msg),\n          _regexParser$exec2 = _slicedToArray(_regexParser$exec, 6),\n          date = _regexParser$exec2[1],\n          time = _regexParser$exec2[2],\n          ampm = _regexParser$exec2[3],\n          author = _regexParser$exec2[4],\n          message = _regexParser$exec2[5];\n\n      return {\n        date: date,\n        time: time,\n        ampm: ampm || null,\n        author: author,\n        message: message\n      };\n    }); // Understand date format if not supplied (days come first?)\n\n    if (typeof daysFirst !== 'boolean') {\n      var numericDates = Array.from(new Set(parsed.map(function (_ref) {\n        var date = _ref.date;\n        return date;\n      })), function (date) {\n        return date.split(regexSplitDate).map(Number);\n      });\n      daysFirst = daysBeforeMonths$1(numericDates);\n    } // Convert date/time in date object, return final object\n\n\n    return parsed.map(function (_ref2) {\n      var date = _ref2.date,\n          time = _ref2.time,\n          ampm = _ref2.ampm,\n          author = _ref2.author,\n          message = _ref2.message;\n      var day;\n      var month;\n      var year;\n\n      if (daysFirst === false) {\n        var _date$split = date.split(regexSplitDate);\n\n        var _date$split2 = _slicedToArray(_date$split, 3);\n\n        month = _date$split2[0];\n        day = _date$split2[1];\n        year = _date$split2[2];\n      } else {\n        var _date$split3 = date.split(regexSplitDate);\n\n        var _date$split4 = _slicedToArray(_date$split3, 3);\n\n        day = _date$split4[0];\n        month = _date$split4[1];\n        year = _date$split4[2];\n      }\n\n      var _normalizeDate = normalizeDate$1(year, month, day);\n\n      var _normalizeDate2 = _slicedToArray(_normalizeDate, 3);\n\n      year = _normalizeDate2[0];\n      month = _normalizeDate2[1];\n      day = _normalizeDate2[2];\n\n      var _normalizeTime$split = normalizeTime$1(ampm ? convertTime12to24$1(time, normalizeAMPM$1(ampm)) : time).split(regexSplitTime$1),\n          _normalizeTime$split2 = _slicedToArray(_normalizeTime$split, 3),\n          hours = _normalizeTime$split2[0],\n          minutes = _normalizeTime$split2[1],\n          seconds = _normalizeTime$split2[2];\n\n      return {\n        date: new Date(year, month - 1, day, hours, minutes, seconds),\n        author: author,\n        message: message\n      };\n    });\n  }\n\n  var parser = {\n    makeArrayOfMessages: makeArrayOfMessages,\n    parseMessages: parseMessages\n  };\n  var makeArrayOfMessages$1 = parser.makeArrayOfMessages,\n      parseMessages$1 = parser.parseMessages;\n  /**\n   * Given a string it will parse its content\n   * Returns a promise that will contain the parsed messages\n   */\n\n  function parseString(string, options) {\n    return Promise.resolve(string).then(function (data) {\n      return data.split('\\n');\n    }).then(makeArrayOfMessages$1).then(function (messages) {\n      return parseMessages$1(messages, options);\n    });\n  }\n\n  var src = {\n    parseString: parseString\n  };\n  var src_1 = src.parseString;\n  exports.default = src;\n  exports.parseString = src_1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}